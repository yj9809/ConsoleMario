#include <iostream>

#include "GameLevel.h"
#include "Actor/Ground.h"
#include "Actor/Wall.h"
#include "Actor/Player.h"
#include "Actor/FakeWall.h"

GameLevel::GameLevel()
{
	LoadMap("1-1.txt");

	AddNewActor(new Player());
}

GameLevel::~GameLevel()
{
}

void GameLevel::Tick(float deltaTime)
{
	super::Tick(deltaTime);

	PlayerAndWallProcessColision();
}

void GameLevel::Draw()
{
    super::Draw();
}

void GameLevel::PlayerAndWallProcessColision()
{
	Actor* player = nullptr;
	std::vector<Actor*> walls;
	for (Actor* const actor : actors)
	{
		if (actor->IsTypeOf<Player>())
		{
			player = actor;
			continue;
		}

		if (actor->IsTypeOf<Wall>())
		{
			walls.push_back(actor);
			continue;
		}
	}
	if (!player || walls.empty())
	{
		return;
	}

	for (Actor* const wall : walls)
	{
		if (player->TestIntersect(wall))
		{
			Vector2 playerPos = player->GetPosition();
			Vector2 wallPos = wall->GetPosition();
			// 충돌 방향에 따른 위치 보정.
			if (playerPos.y + player->GetWidth() - 1 >= wallPos.y
				&& playerPos.y < wallPos.y) // 아래쪽 충돌
			{
				player->SetPosition(Vector2(playerPos.x, wallPos.y - player->GetWidth()));
			}
			else if (playerPos.y <= wallPos.y + wall->GetWidth() - 1
				&& playerPos.y > wallPos.y) // 위쪽 충돌
			{
				player->SetPosition(Vector2(playerPos.x, wallPos.y + wall->GetWidth()));
			}
			else if (playerPos.x + player->GetWidth() - 1 >= wallPos.x
				&& playerPos.x < wallPos.x) // 오른쪽 충돌
			{
				player->SetPosition(Vector2(wallPos.x - player->GetWidth(), playerPos.y));
			}
			else if (playerPos.x <= wallPos.x + wall->GetWidth() - 1
				&& playerPos.x > wallPos.x) // 왼쪽 충돌
			{
				player->SetPosition(Vector2(wallPos.x + wall->GetWidth(), playerPos.y));
			}
		}
	}

}

bool GameLevel::CanMove(const Vector2& playerPosition, const Vector2& nextPosition)
{
	// 레벨에 있는 벽 액터 수집.
	std::vector<Actor*> walls;

	for (Actor* const actor : actors)
	{
		if (actor->IsTypeOf<Wall>())
		{
			walls.push_back(actor);
			continue;
		}
	}

	for (Actor* const wall : walls)
	{
		if (wall->GetPosition() == nextPosition)
		{
			return false;
		}
	}

	return true;
}

bool GameLevel::IsOnGround(const Vector2& playerDownPosition)
{
	// 레벨에 있는 땅 액터 수집.
	std::vector<Actor*> grounds;

	for (Actor* actor : actors)
	{
		if (actor->IsTypeOf<Wall>())
		{
			grounds.push_back(actor);
			continue;
		}
	}

	for (Actor* ground : grounds)
	{
		if (ground->GetPosition() == playerDownPosition)
		{
			return true;
		}
	}
	return false;
}

void GameLevel::LoadMap(const char* mapFile)
{
	char path[2048] = {};
	sprintf_s(path, 2048, "../Assets/Maps/%s", mapFile);

	FILE* file = nullptr;
	fopen_s(&file, path, "rt");

	if (!file)
	{
		std::cerr << "GameLevel::LoadMap - Failed to open map file.\n";

		__debugbreak();
	}

	fseek(file, 0, SEEK_END);

	size_t fileSize = ftell(file);

	rewind(file);

	char* buffer = new char[fileSize + 1];

	size_t readSize = fread(buffer, sizeof(char), fileSize, file);

	int index = 0;

	Wanted::Vector2 position;

	while (true)
	{
		if (index >= fileSize)
		{
			break;
		}

		char mapCharacter = buffer[index];
		++index;

		if (mapCharacter == '\n')
		{
			++position.y;
			position.x = 0;
			continue;
		}
		switch (mapCharacter)
		{
		case '#':
			AddNewActor(new Wall(position));
			break;
		case '=':
			AddNewActor(new FakeWall(position));
			break;
		case 'G':
			AddNewActor(new Ground(position));
		}
		++position.x;
	}

	delete[] buffer;
	fclose(file);
}
